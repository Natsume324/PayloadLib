// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: update_metadata.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ChromeosUpdateEngine {

  /// <summary>Holder for reflection information generated from update_metadata.proto</summary>
  public static partial class UpdateMetadataReflection {

    #region Descriptor
    /// <summary>File descriptor for update_metadata.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UpdateMetadataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChV1cGRhdGVfbWV0YWRhdGEucHJvdG8SFmNocm9tZW9zX3VwZGF0ZV9lbmdp",
            "bmUiMQoGRXh0ZW50EhMKC3N0YXJ0X2Jsb2NrGAEgASgEEhIKCm51bV9ibG9j",
            "a3MYAiABKAQinwEKClNpZ25hdHVyZXMSQAoKc2lnbmF0dXJlcxgBIAMoCzIs",
            "LmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuU2lnbmF0dXJlcy5TaWduYXR1cmUa",
            "TwoJU2lnbmF0dXJlEhMKB3ZlcnNpb24YASABKA1CAhgBEgwKBGRhdGEYAiAB",
            "KAwSHwoXdW5wYWRkZWRfc2lnbmF0dXJlX3NpemUYAyABKAciKwoNUGFydGl0",
            "aW9uSW5mbxIMCgRzaXplGAEgASgEEgwKBGhhc2gYAiABKAwipgQKEEluc3Rh",
            "bGxPcGVyYXRpb24SOwoEdHlwZRgBIAIoDjItLmNocm9tZW9zX3VwZGF0ZV9l",
            "bmdpbmUuSW5zdGFsbE9wZXJhdGlvbi5UeXBlEhMKC2RhdGFfb2Zmc2V0GAIg",
            "ASgEEhMKC2RhdGFfbGVuZ3RoGAMgASgEEjMKC3NyY19leHRlbnRzGAQgAygL",
            "Mh4uY2hyb21lb3NfdXBkYXRlX2VuZ2luZS5FeHRlbnQSEgoKc3JjX2xlbmd0",
            "aBgFIAEoBBIzCgtkc3RfZXh0ZW50cxgGIAMoCzIeLmNocm9tZW9zX3VwZGF0",
            "ZV9lbmdpbmUuRXh0ZW50EhIKCmRzdF9sZW5ndGgYByABKAQSGAoQZGF0YV9z",
            "aGEyNTZfaGFzaBgIIAEoDBIXCg9zcmNfc2hhMjU2X2hhc2gYCSABKAwi5QEK",
            "BFR5cGUSCwoHUkVQTEFDRRAAEg4KClJFUExBQ0VfQloQARIMCgRNT1ZFEAIa",
            "AggBEg4KBkJTRElGRhADGgIIARIPCgtTT1VSQ0VfQ09QWRAEEhEKDVNPVVJD",
            "RV9CU0RJRkYQBRIOCgpSRVBMQUNFX1haEAgSCAoEWkVSTxAGEgsKB0RJU0NB",
            "UkQQBxIRCg1CUk9UTElfQlNESUZGEAoSDAoIUFVGRkRJRkYQCRIMCghaVUND",
            "SElOSRALEhIKDkxaNERJRkZfQlNESUZGEAwSFAoQTFo0RElGRl9QVUZGRElG",
            "RhANIoECChFDb3dNZXJnZU9wZXJhdGlvbhI8CgR0eXBlGAEgASgOMi4uY2hy",
            "b21lb3NfdXBkYXRlX2VuZ2luZS5Db3dNZXJnZU9wZXJhdGlvbi5UeXBlEjIK",
            "CnNyY19leHRlbnQYAiABKAsyHi5jaHJvbWVvc191cGRhdGVfZW5naW5lLkV4",
            "dGVudBIyCgpkc3RfZXh0ZW50GAMgASgLMh4uY2hyb21lb3NfdXBkYXRlX2Vu",
            "Z2luZS5FeHRlbnQSEgoKc3JjX29mZnNldBgEIAEoDSIyCgRUeXBlEgwKCENP",
            "V19DT1BZEAASCwoHQ09XX1hPUhABEg8KC0NPV19SRVBMQUNFEAIi5wYKD1Bh",
            "cnRpdGlvblVwZGF0ZRIWCg5wYXJ0aXRpb25fbmFtZRgBIAIoCRIXCg9ydW5f",
            "cG9zdGluc3RhbGwYAiABKAgSGAoQcG9zdGluc3RhbGxfcGF0aBgDIAEoCRIX",
            "Cg9maWxlc3lzdGVtX3R5cGUYBCABKAkSTQoXbmV3X3BhcnRpdGlvbl9zaWdu",
            "YXR1cmUYBSADKAsyLC5jaHJvbWVvc191cGRhdGVfZW5naW5lLlNpZ25hdHVy",
            "ZXMuU2lnbmF0dXJlEkEKEm9sZF9wYXJ0aXRpb25faW5mbxgGIAEoCzIlLmNo",
            "cm9tZW9zX3VwZGF0ZV9lbmdpbmUuUGFydGl0aW9uSW5mbxJBChJuZXdfcGFy",
            "dGl0aW9uX2luZm8YByABKAsyJS5jaHJvbWVvc191cGRhdGVfZW5naW5lLlBh",
            "cnRpdGlvbkluZm8SPAoKb3BlcmF0aW9ucxgIIAMoCzIoLmNocm9tZW9zX3Vw",
            "ZGF0ZV9lbmdpbmUuSW5zdGFsbE9wZXJhdGlvbhIcChRwb3N0aW5zdGFsbF9v",
            "cHRpb25hbBgJIAEoCBI9ChVoYXNoX3RyZWVfZGF0YV9leHRlbnQYCiABKAsy",
            "Hi5jaHJvbWVvc191cGRhdGVfZW5naW5lLkV4dGVudBI4ChBoYXNoX3RyZWVf",
            "ZXh0ZW50GAsgASgLMh4uY2hyb21lb3NfdXBkYXRlX2VuZ2luZS5FeHRlbnQS",
            "GwoTaGFzaF90cmVlX2FsZ29yaXRobRgMIAEoCRIWCg5oYXNoX3RyZWVfc2Fs",
            "dBgNIAEoDBI3Cg9mZWNfZGF0YV9leHRlbnQYDiABKAsyHi5jaHJvbWVvc191",
            "cGRhdGVfZW5naW5lLkV4dGVudBIyCgpmZWNfZXh0ZW50GA8gASgLMh4uY2hy",
            "b21lb3NfdXBkYXRlX2VuZ2luZS5FeHRlbnQSFAoJZmVjX3Jvb3RzGBAgASgN",
            "OgEyEg8KB3ZlcnNpb24YESABKAkSQwoQbWVyZ2Vfb3BlcmF0aW9ucxgSIAMo",
            "CzIpLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuQ293TWVyZ2VPcGVyYXRpb24S",
            "GQoRZXN0aW1hdGVfY293X3NpemUYEyABKAQSHQoVZXN0aW1hdGVfb3BfY291",
            "bnRfbWF4GBQgASgEIkwKFUR5bmFtaWNQYXJ0aXRpb25Hcm91cBIMCgRuYW1l",
            "GAEgAigJEgwKBHNpemUYAiABKAQSFwoPcGFydGl0aW9uX25hbWVzGAMgAygJ",
            "IjgKDlZBQkNGZWF0dXJlU2V0EhAKCHRocmVhZGVkGAEgASgIEhQKDGJhdGNo",
            "X3dyaXRlcxgCIAEoCCKcAgoYRHluYW1pY1BhcnRpdGlvbk1ldGFkYXRhEj0K",
            "Bmdyb3VwcxgBIAMoCzItLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuRHluYW1p",
            "Y1BhcnRpdGlvbkdyb3VwEhgKEHNuYXBzaG90X2VuYWJsZWQYAiABKAgSFAoM",
            "dmFiY19lbmFibGVkGAMgASgIEh4KFnZhYmNfY29tcHJlc3Npb25fcGFyYW0Y",
            "BCABKAkSEwoLY293X3ZlcnNpb24YBSABKA0SQAoQdmFiY19mZWF0dXJlX3Nl",
            "dBgGIAEoCzImLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuVkFCQ0ZlYXR1cmVT",
            "ZXQSGgoSY29tcHJlc3Npb25fZmFjdG9yGAcgASgEImMKCEFwZXhJbmZvEhQK",
            "DHBhY2thZ2VfbmFtZRgBIAEoCRIPCgd2ZXJzaW9uGAIgASgDEhUKDWlzX2Nv",
            "bXByZXNzZWQYAyABKAgSGQoRZGVjb21wcmVzc2VkX3NpemUYBCABKAMiQwoM",
            "QXBleE1ldGFkYXRhEjMKCWFwZXhfaW5mbxgBIAMoCzIgLmNocm9tZW9zX3Vw",
            "ZGF0ZV9lbmdpbmUuQXBleEluZm8iwwMKFERlbHRhQXJjaGl2ZU1hbmlmZXN0",
            "EhgKCmJsb2NrX3NpemUYAyABKA06BDQwOTYSGQoRc2lnbmF0dXJlc19vZmZz",
            "ZXQYBCABKAQSFwoPc2lnbmF0dXJlc19zaXplGAUgASgEEhgKDW1pbm9yX3Zl",
            "cnNpb24YDCABKA06ATASOwoKcGFydGl0aW9ucxgNIAMoCzInLmNocm9tZW9z",
            "X3VwZGF0ZV9lbmdpbmUuUGFydGl0aW9uVXBkYXRlEhUKDW1heF90aW1lc3Rh",
            "bXAYDiABKAMSVAoaZHluYW1pY19wYXJ0aXRpb25fbWV0YWRhdGEYDyABKAsy",
            "MC5jaHJvbWVvc191cGRhdGVfZW5naW5lLkR5bmFtaWNQYXJ0aXRpb25NZXRh",
            "ZGF0YRIWCg5wYXJ0aWFsX3VwZGF0ZRgQIAEoCBIzCglhcGV4X2luZm8YESAD",
            "KAsyIC5jaHJvbWVvc191cGRhdGVfZW5naW5lLkFwZXhJbmZvEhwKFHNlY3Vy",
            "aXR5X3BhdGNoX2xldmVsGBIgASgJSgQIARACSgQIAhADSgQIBhAHSgQIBxAI",
            "SgQICBAJSgQICRAKSgQIChALSgQICxAM"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Extent), global::ChromeosUpdateEngine.Extent.Parser, new[]{ "StartBlock", "NumBlocks" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Signatures), global::ChromeosUpdateEngine.Signatures.Parser, new[]{ "Signatures_" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Signatures.Types.Signature), global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser, new[]{ "Version", "Data", "UnpaddedSignatureSize" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.PartitionInfo), global::ChromeosUpdateEngine.PartitionInfo.Parser, new[]{ "Size", "Hash" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.InstallOperation), global::ChromeosUpdateEngine.InstallOperation.Parser, new[]{ "Type", "DataOffset", "DataLength", "SrcExtents", "SrcLength", "DstExtents", "DstLength", "DataSha256Hash", "SrcSha256Hash" }, null, new[]{ typeof(global::ChromeosUpdateEngine.InstallOperation.Types.Type) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.CowMergeOperation), global::ChromeosUpdateEngine.CowMergeOperation.Parser, new[]{ "Type", "SrcExtent", "DstExtent", "SrcOffset" }, null, new[]{ typeof(global::ChromeosUpdateEngine.CowMergeOperation.Types.Type) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.PartitionUpdate), global::ChromeosUpdateEngine.PartitionUpdate.Parser, new[]{ "PartitionName", "RunPostinstall", "PostinstallPath", "FilesystemType", "NewPartitionSignature", "OldPartitionInfo", "NewPartitionInfo", "Operations", "PostinstallOptional", "HashTreeDataExtent", "HashTreeExtent", "HashTreeAlgorithm", "HashTreeSalt", "FecDataExtent", "FecExtent", "FecRoots", "Version", "MergeOperations", "EstimateCowSize", "EstimateOpCountMax" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DynamicPartitionGroup), global::ChromeosUpdateEngine.DynamicPartitionGroup.Parser, new[]{ "Name", "Size", "PartitionNames" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.VABCFeatureSet), global::ChromeosUpdateEngine.VABCFeatureSet.Parser, new[]{ "Threaded", "BatchWrites" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DynamicPartitionMetadata), global::ChromeosUpdateEngine.DynamicPartitionMetadata.Parser, new[]{ "Groups", "SnapshotEnabled", "VabcEnabled", "VabcCompressionParam", "CowVersion", "VabcFeatureSet", "CompressionFactor" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.ApexInfo), global::ChromeosUpdateEngine.ApexInfo.Parser, new[]{ "PackageName", "Version", "IsCompressed", "DecompressedSize" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.ApexMetadata), global::ChromeosUpdateEngine.ApexMetadata.Parser, new[]{ "ApexInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DeltaArchiveManifest), global::ChromeosUpdateEngine.DeltaArchiveManifest.Parser, new[]{ "BlockSize", "SignaturesOffset", "SignaturesSize", "MinorVersion", "Partitions", "MaxTimestamp", "DynamicPartitionMetadata", "PartialUpdate", "ApexInfo", "SecurityPatchLevel" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Extent : pb::IMessage<Extent>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Extent> _parser = new pb::MessageParser<Extent>(() => new Extent());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Extent> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Extent() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Extent(Extent other) : this() {
      _hasBits0 = other._hasBits0;
      startBlock_ = other.startBlock_;
      numBlocks_ = other.numBlocks_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Extent Clone() {
      return new Extent(this);
    }

    /// <summary>Field number for the "start_block" field.</summary>
    public const int StartBlockFieldNumber = 1;
    private readonly static ulong StartBlockDefaultValue = 0UL;

    private ulong startBlock_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong StartBlock {
      get { if ((_hasBits0 & 1) != 0) { return startBlock_; } else { return StartBlockDefaultValue; } }
      set {
        _hasBits0 |= 1;
        startBlock_ = value;
      }
    }
    /// <summary>Gets whether the "start_block" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStartBlock {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "start_block" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStartBlock() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "num_blocks" field.</summary>
    public const int NumBlocksFieldNumber = 2;
    private readonly static ulong NumBlocksDefaultValue = 0UL;

    private ulong numBlocks_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong NumBlocks {
      get { if ((_hasBits0 & 2) != 0) { return numBlocks_; } else { return NumBlocksDefaultValue; } }
      set {
        _hasBits0 |= 2;
        numBlocks_ = value;
      }
    }
    /// <summary>Gets whether the "num_blocks" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumBlocks {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "num_blocks" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumBlocks() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Extent);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Extent other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartBlock != other.StartBlock) return false;
      if (NumBlocks != other.NumBlocks) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStartBlock) hash ^= StartBlock.GetHashCode();
      if (HasNumBlocks) hash ^= NumBlocks.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStartBlock) {
        output.WriteRawTag(8);
        output.WriteUInt64(StartBlock);
      }
      if (HasNumBlocks) {
        output.WriteRawTag(16);
        output.WriteUInt64(NumBlocks);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStartBlock) {
        output.WriteRawTag(8);
        output.WriteUInt64(StartBlock);
      }
      if (HasNumBlocks) {
        output.WriteRawTag(16);
        output.WriteUInt64(NumBlocks);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasStartBlock) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(StartBlock);
      }
      if (HasNumBlocks) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(NumBlocks);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Extent other) {
      if (other == null) {
        return;
      }
      if (other.HasStartBlock) {
        StartBlock = other.StartBlock;
      }
      if (other.HasNumBlocks) {
        NumBlocks = other.NumBlocks;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            StartBlock = input.ReadUInt64();
            break;
          }
          case 16: {
            NumBlocks = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            StartBlock = input.ReadUInt64();
            break;
          }
          case 16: {
            NumBlocks = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Signatures : pb::IMessage<Signatures>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Signatures> _parser = new pb::MessageParser<Signatures>(() => new Signatures());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Signatures> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signatures() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signatures(Signatures other) : this() {
      signatures_ = other.signatures_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signatures Clone() {
      return new Signatures(this);
    }

    /// <summary>Field number for the "signatures" field.</summary>
    public const int Signatures_FieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Signatures.Types.Signature> _repeated_signatures_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> signatures_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> Signatures_ {
      get { return signatures_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Signatures);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Signatures other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!signatures_.Equals(other.signatures_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= signatures_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      signatures_.WriteTo(output, _repeated_signatures_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      signatures_.WriteTo(ref output, _repeated_signatures_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += signatures_.CalculateSize(_repeated_signatures_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Signatures other) {
      if (other == null) {
        return;
      }
      signatures_.Add(other.signatures_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            signatures_.AddEntriesFrom(input, _repeated_signatures_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            signatures_.AddEntriesFrom(ref input, _repeated_signatures_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Signatures message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Signature : pb::IMessage<Signature>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Signature> _parser = new pb::MessageParser<Signature>(() => new Signature());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Signature> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ChromeosUpdateEngine.Signatures.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Signature() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Signature(Signature other) : this() {
          _hasBits0 = other._hasBits0;
          version_ = other.version_;
          data_ = other.data_;
          unpaddedSignatureSize_ = other.unpaddedSignatureSize_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Signature Clone() {
          return new Signature(this);
        }

        /// <summary>Field number for the "version" field.</summary>
        public const int VersionFieldNumber = 1;
        private readonly static uint VersionDefaultValue = 0;

        private uint version_;
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint Version {
          get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
          set {
            _hasBits0 |= 1;
            version_ = value;
          }
        }
        /// <summary>Gets whether the "version" field is set</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVersion {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "version" field</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVersion() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "data" field.</summary>
        public const int DataFieldNumber = 2;
        private readonly static pb::ByteString DataDefaultValue = pb::ByteString.Empty;

        private pb::ByteString data_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Data {
          get { return data_ ?? DataDefaultValue; }
          set {
            data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "data" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasData {
          get { return data_ != null; }
        }
        /// <summary>Clears the value of the "data" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearData() {
          data_ = null;
        }

        /// <summary>Field number for the "unpadded_signature_size" field.</summary>
        public const int UnpaddedSignatureSizeFieldNumber = 3;
        private readonly static uint UnpaddedSignatureSizeDefaultValue = 0;

        private uint unpaddedSignatureSize_;
        /// <summary>
        /// The DER encoded signature size of EC keys is nondeterministic for
        /// different input of sha256 hash. However, we need the size of the
        /// serialized signatures protobuf string to be fixed before signing;
        /// because this size is part of the content to be signed. Therefore, we
        /// always pad the signature data to the maximum possible signature size of
        /// a given key. And the payload verifier will truncate the signature to
        /// its correct size based on the value of |unpadded_signature_size|.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint UnpaddedSignatureSize {
          get { if ((_hasBits0 & 2) != 0) { return unpaddedSignatureSize_; } else { return UnpaddedSignatureSizeDefaultValue; } }
          set {
            _hasBits0 |= 2;
            unpaddedSignatureSize_ = value;
          }
        }
        /// <summary>Gets whether the "unpadded_signature_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUnpaddedSignatureSize {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "unpadded_signature_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUnpaddedSignatureSize() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Signature);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Signature other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Version != other.Version) return false;
          if (Data != other.Data) return false;
          if (UnpaddedSignatureSize != other.UnpaddedSignatureSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasVersion) hash ^= Version.GetHashCode();
          if (HasData) hash ^= Data.GetHashCode();
          if (HasUnpaddedSignatureSize) hash ^= UnpaddedSignatureSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasVersion) {
            output.WriteRawTag(8);
            output.WriteUInt32(Version);
          }
          if (HasData) {
            output.WriteRawTag(18);
            output.WriteBytes(Data);
          }
          if (HasUnpaddedSignatureSize) {
            output.WriteRawTag(29);
            output.WriteFixed32(UnpaddedSignatureSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasVersion) {
            output.WriteRawTag(8);
            output.WriteUInt32(Version);
          }
          if (HasData) {
            output.WriteRawTag(18);
            output.WriteBytes(Data);
          }
          if (HasUnpaddedSignatureSize) {
            output.WriteRawTag(29);
            output.WriteFixed32(UnpaddedSignatureSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasVersion) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
          }
          if (HasData) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
          }
          if (HasUnpaddedSignatureSize) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Signature other) {
          if (other == null) {
            return;
          }
          if (other.HasVersion) {
            Version = other.Version;
          }
          if (other.HasData) {
            Data = other.Data;
          }
          if (other.HasUnpaddedSignatureSize) {
            UnpaddedSignatureSize = other.UnpaddedSignatureSize;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Version = input.ReadUInt32();
                break;
              }
              case 18: {
                Data = input.ReadBytes();
                break;
              }
              case 29: {
                UnpaddedSignatureSize = input.ReadFixed32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Version = input.ReadUInt32();
                break;
              }
              case 18: {
                Data = input.ReadBytes();
                break;
              }
              case 29: {
                UnpaddedSignatureSize = input.ReadFixed32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PartitionInfo : pb::IMessage<PartitionInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PartitionInfo> _parser = new pb::MessageParser<PartitionInfo>(() => new PartitionInfo());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PartitionInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionInfo(PartitionInfo other) : this() {
      _hasBits0 = other._hasBits0;
      size_ = other.size_;
      hash_ = other.hash_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionInfo Clone() {
      return new PartitionInfo(this);
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 1;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "hash" field.</summary>
    public const int HashFieldNumber = 2;
    private readonly static pb::ByteString HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString hash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Hash {
      get { return hash_ ?? HashDefaultValue; }
      set {
        hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHash {
      get { return hash_ != null; }
    }
    /// <summary>Clears the value of the "hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHash() {
      hash_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PartitionInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PartitionInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Size != other.Size) return false;
      if (Hash != other.Hash) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSize) hash ^= Size.GetHashCode();
      if (HasHash) hash ^= Hash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSize) {
        output.WriteRawTag(8);
        output.WriteUInt64(Size);
      }
      if (HasHash) {
        output.WriteRawTag(18);
        output.WriteBytes(Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSize) {
        output.WriteRawTag(8);
        output.WriteUInt64(Size);
      }
      if (HasHash) {
        output.WriteRawTag(18);
        output.WriteBytes(Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      if (HasHash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Hash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PartitionInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      if (other.HasHash) {
        Hash = other.Hash;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Size = input.ReadUInt64();
            break;
          }
          case 18: {
            Hash = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Size = input.ReadUInt64();
            break;
          }
          case 18: {
            Hash = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class InstallOperation : pb::IMessage<InstallOperation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstallOperation> _parser = new pb::MessageParser<InstallOperation>(() => new InstallOperation());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstallOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallOperation(InstallOperation other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      dataOffset_ = other.dataOffset_;
      dataLength_ = other.dataLength_;
      srcExtents_ = other.srcExtents_.Clone();
      srcLength_ = other.srcLength_;
      dstExtents_ = other.dstExtents_.Clone();
      dstLength_ = other.dstLength_;
      dataSha256Hash_ = other.dataSha256Hash_;
      srcSha256Hash_ = other.srcSha256Hash_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstallOperation Clone() {
      return new InstallOperation(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::ChromeosUpdateEngine.InstallOperation.Types.Type TypeDefaultValue = global::ChromeosUpdateEngine.InstallOperation.Types.Type.Replace;

    private global::ChromeosUpdateEngine.InstallOperation.Types.Type type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.InstallOperation.Types.Type Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "data_offset" field.</summary>
    public const int DataOffsetFieldNumber = 2;
    private readonly static ulong DataOffsetDefaultValue = 0UL;

    private ulong dataOffset_;
    /// <summary>
    /// Only minor version 6 or newer support 64 bits |data_offset| and
    /// |data_length|, older client will read them as uint32.
    /// The offset into the delta file (after the protobuf)
    /// where the data (if any) is stored
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong DataOffset {
      get { if ((_hasBits0 & 2) != 0) { return dataOffset_; } else { return DataOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        dataOffset_ = value;
      }
    }
    /// <summary>Gets whether the "data_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDataOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "data_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDataOffset() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "data_length" field.</summary>
    public const int DataLengthFieldNumber = 3;
    private readonly static ulong DataLengthDefaultValue = 0UL;

    private ulong dataLength_;
    /// <summary>
    /// The length of the data in the delta file
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong DataLength {
      get { if ((_hasBits0 & 4) != 0) { return dataLength_; } else { return DataLengthDefaultValue; } }
      set {
        _hasBits0 |= 4;
        dataLength_ = value;
      }
    }
    /// <summary>Gets whether the "data_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDataLength {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "data_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDataLength() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "src_extents" field.</summary>
    public const int SrcExtentsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Extent> _repeated_srcExtents_codec
        = pb::FieldCodec.ForMessage(34, global::ChromeosUpdateEngine.Extent.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> srcExtents_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Extent>();
    /// <summary>
    /// Ordered list of extents that are read from (if any) and written to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> SrcExtents {
      get { return srcExtents_; }
    }

    /// <summary>Field number for the "src_length" field.</summary>
    public const int SrcLengthFieldNumber = 5;
    private readonly static ulong SrcLengthDefaultValue = 0UL;

    private ulong srcLength_;
    /// <summary>
    /// Byte length of src, equal to the number of blocks in src_extents *
    /// block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
    /// pass that external program the number of bytes to read from the blocks we
    /// pass it.  This is not used in any other operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SrcLength {
      get { if ((_hasBits0 & 8) != 0) { return srcLength_; } else { return SrcLengthDefaultValue; } }
      set {
        _hasBits0 |= 8;
        srcLength_ = value;
      }
    }
    /// <summary>Gets whether the "src_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSrcLength {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "src_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSrcLength() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "dst_extents" field.</summary>
    public const int DstExtentsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Extent> _repeated_dstExtents_codec
        = pb::FieldCodec.ForMessage(50, global::ChromeosUpdateEngine.Extent.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> dstExtents_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Extent>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> DstExtents {
      get { return dstExtents_; }
    }

    /// <summary>Field number for the "dst_length" field.</summary>
    public const int DstLengthFieldNumber = 7;
    private readonly static ulong DstLengthDefaultValue = 0UL;

    private ulong dstLength_;
    /// <summary>
    /// Byte length of dst, equal to the number of blocks in dst_extents *
    /// block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
    /// operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong DstLength {
      get { if ((_hasBits0 & 16) != 0) { return dstLength_; } else { return DstLengthDefaultValue; } }
      set {
        _hasBits0 |= 16;
        dstLength_ = value;
      }
    }
    /// <summary>Gets whether the "dst_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDstLength {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "dst_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDstLength() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "data_sha256_hash" field.</summary>
    public const int DataSha256HashFieldNumber = 8;
    private readonly static pb::ByteString DataSha256HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString dataSha256Hash_;
    /// <summary>
    /// Optional SHA 256 hash of the blob associated with this operation.
    /// This is used as a primary validation for http-based downloads and
    /// as a defense-in-depth validation for https-based downloads. If
    /// the operation doesn't refer to any blob, this field will have
    /// zero bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DataSha256Hash {
      get { return dataSha256Hash_ ?? DataSha256HashDefaultValue; }
      set {
        dataSha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "data_sha256_hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDataSha256Hash {
      get { return dataSha256Hash_ != null; }
    }
    /// <summary>Clears the value of the "data_sha256_hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDataSha256Hash() {
      dataSha256Hash_ = null;
    }

    /// <summary>Field number for the "src_sha256_hash" field.</summary>
    public const int SrcSha256HashFieldNumber = 9;
    private readonly static pb::ByteString SrcSha256HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString srcSha256Hash_;
    /// <summary>
    /// Indicates the SHA 256 hash of the source data referenced in src_extents at
    /// the time of applying the operation. If present, the update_engine daemon
    /// MUST read and verify the source data before applying the operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SrcSha256Hash {
      get { return srcSha256Hash_ ?? SrcSha256HashDefaultValue; }
      set {
        srcSha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "src_sha256_hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSrcSha256Hash {
      get { return srcSha256Hash_ != null; }
    }
    /// <summary>Clears the value of the "src_sha256_hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSrcSha256Hash() {
      srcSha256Hash_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstallOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstallOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (DataOffset != other.DataOffset) return false;
      if (DataLength != other.DataLength) return false;
      if(!srcExtents_.Equals(other.srcExtents_)) return false;
      if (SrcLength != other.SrcLength) return false;
      if(!dstExtents_.Equals(other.dstExtents_)) return false;
      if (DstLength != other.DstLength) return false;
      if (DataSha256Hash != other.DataSha256Hash) return false;
      if (SrcSha256Hash != other.SrcSha256Hash) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasDataOffset) hash ^= DataOffset.GetHashCode();
      if (HasDataLength) hash ^= DataLength.GetHashCode();
      hash ^= srcExtents_.GetHashCode();
      if (HasSrcLength) hash ^= SrcLength.GetHashCode();
      hash ^= dstExtents_.GetHashCode();
      if (HasDstLength) hash ^= DstLength.GetHashCode();
      if (HasDataSha256Hash) hash ^= DataSha256Hash.GetHashCode();
      if (HasSrcSha256Hash) hash ^= SrcSha256Hash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasDataOffset) {
        output.WriteRawTag(16);
        output.WriteUInt64(DataOffset);
      }
      if (HasDataLength) {
        output.WriteRawTag(24);
        output.WriteUInt64(DataLength);
      }
      srcExtents_.WriteTo(output, _repeated_srcExtents_codec);
      if (HasSrcLength) {
        output.WriteRawTag(40);
        output.WriteUInt64(SrcLength);
      }
      dstExtents_.WriteTo(output, _repeated_dstExtents_codec);
      if (HasDstLength) {
        output.WriteRawTag(56);
        output.WriteUInt64(DstLength);
      }
      if (HasDataSha256Hash) {
        output.WriteRawTag(66);
        output.WriteBytes(DataSha256Hash);
      }
      if (HasSrcSha256Hash) {
        output.WriteRawTag(74);
        output.WriteBytes(SrcSha256Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasDataOffset) {
        output.WriteRawTag(16);
        output.WriteUInt64(DataOffset);
      }
      if (HasDataLength) {
        output.WriteRawTag(24);
        output.WriteUInt64(DataLength);
      }
      srcExtents_.WriteTo(ref output, _repeated_srcExtents_codec);
      if (HasSrcLength) {
        output.WriteRawTag(40);
        output.WriteUInt64(SrcLength);
      }
      dstExtents_.WriteTo(ref output, _repeated_dstExtents_codec);
      if (HasDstLength) {
        output.WriteRawTag(56);
        output.WriteUInt64(DstLength);
      }
      if (HasDataSha256Hash) {
        output.WriteRawTag(66);
        output.WriteBytes(DataSha256Hash);
      }
      if (HasSrcSha256Hash) {
        output.WriteRawTag(74);
        output.WriteBytes(SrcSha256Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasDataOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DataOffset);
      }
      if (HasDataLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DataLength);
      }
      size += srcExtents_.CalculateSize(_repeated_srcExtents_codec);
      if (HasSrcLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SrcLength);
      }
      size += dstExtents_.CalculateSize(_repeated_dstExtents_codec);
      if (HasDstLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DstLength);
      }
      if (HasDataSha256Hash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DataSha256Hash);
      }
      if (HasSrcSha256Hash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SrcSha256Hash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstallOperation other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasDataOffset) {
        DataOffset = other.DataOffset;
      }
      if (other.HasDataLength) {
        DataLength = other.DataLength;
      }
      srcExtents_.Add(other.srcExtents_);
      if (other.HasSrcLength) {
        SrcLength = other.SrcLength;
      }
      dstExtents_.Add(other.dstExtents_);
      if (other.HasDstLength) {
        DstLength = other.DstLength;
      }
      if (other.HasDataSha256Hash) {
        DataSha256Hash = other.DataSha256Hash;
      }
      if (other.HasSrcSha256Hash) {
        SrcSha256Hash = other.SrcSha256Hash;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::ChromeosUpdateEngine.InstallOperation.Types.Type) input.ReadEnum();
            break;
          }
          case 16: {
            DataOffset = input.ReadUInt64();
            break;
          }
          case 24: {
            DataLength = input.ReadUInt64();
            break;
          }
          case 34: {
            srcExtents_.AddEntriesFrom(input, _repeated_srcExtents_codec);
            break;
          }
          case 40: {
            SrcLength = input.ReadUInt64();
            break;
          }
          case 50: {
            dstExtents_.AddEntriesFrom(input, _repeated_dstExtents_codec);
            break;
          }
          case 56: {
            DstLength = input.ReadUInt64();
            break;
          }
          case 66: {
            DataSha256Hash = input.ReadBytes();
            break;
          }
          case 74: {
            SrcSha256Hash = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::ChromeosUpdateEngine.InstallOperation.Types.Type) input.ReadEnum();
            break;
          }
          case 16: {
            DataOffset = input.ReadUInt64();
            break;
          }
          case 24: {
            DataLength = input.ReadUInt64();
            break;
          }
          case 34: {
            srcExtents_.AddEntriesFrom(ref input, _repeated_srcExtents_codec);
            break;
          }
          case 40: {
            SrcLength = input.ReadUInt64();
            break;
          }
          case 50: {
            dstExtents_.AddEntriesFrom(ref input, _repeated_dstExtents_codec);
            break;
          }
          case 56: {
            DstLength = input.ReadUInt64();
            break;
          }
          case 66: {
            DataSha256Hash = input.ReadBytes();
            break;
          }
          case 74: {
            SrcSha256Hash = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the InstallOperation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Type {
        /// <summary>
        /// Replace destination extents w/ attached data.
        /// </summary>
        [pbr::OriginalName("REPLACE")] Replace = 0,
        /// <summary>
        /// Replace destination extents w/ attached bzipped data.
        /// </summary>
        [pbr::OriginalName("REPLACE_BZ")] ReplaceBz = 1,
        /// <summary>
        /// Move source extents to target extents.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [pbr::OriginalName("MOVE")] Move = 2,
        /// <summary>
        /// The data is a bsdiff binary diff.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [pbr::OriginalName("BSDIFF")] Bsdiff = 3,
        /// <summary>
        /// On minor version 2 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("SOURCE_COPY")] SourceCopy = 4,
        /// <summary>
        /// Like BSDIFF, but read from source partition
        /// </summary>
        [pbr::OriginalName("SOURCE_BSDIFF")] SourceBsdiff = 5,
        /// <summary>
        /// On minor version 3 or newer and on major version 2 or newer, these
        /// operations are supported:
        /// </summary>
        [pbr::OriginalName("REPLACE_XZ")] ReplaceXz = 8,
        /// <summary>
        /// On minor version 4 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("ZERO")] Zero = 6,
        /// <summary>
        /// Discard the destination blocks, reading as undefined.
        /// </summary>
        [pbr::OriginalName("DISCARD")] Discard = 7,
        /// <summary>
        /// Like SOURCE_BSDIFF, but compressed with brotli.
        /// </summary>
        [pbr::OriginalName("BROTLI_BSDIFF")] BrotliBsdiff = 10,
        /// <summary>
        /// On minor version 5 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("PUFFDIFF")] Puffdiff = 9,
        /// <summary>
        /// On minor version 8 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("ZUCCHINI")] Zucchini = 11,
        /// <summary>
        /// On minor version 9 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("LZ4DIFF_BSDIFF")] Lz4DiffBsdiff = 12,
        [pbr::OriginalName("LZ4DIFF_PUFFDIFF")] Lz4DiffPuffdiff = 13,
      }

    }
    #endregion

  }

  /// <summary>
  /// Hints to VAB snapshot to skip writing some blocks if these blocks are
  /// identical to the ones on the source image. The src &amp; dst extents for each
  /// CowMergeOperation should be contiguous, and they're a subset of an OTA
  /// InstallOperation.
  /// During merge time, we need to follow the pre-computed sequence to avoid
  /// read after write, similar to the inplace update schema.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CowMergeOperation : pb::IMessage<CowMergeOperation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CowMergeOperation> _parser = new pb::MessageParser<CowMergeOperation>(() => new CowMergeOperation());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CowMergeOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CowMergeOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CowMergeOperation(CowMergeOperation other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      srcExtent_ = other.srcExtent_ != null ? other.srcExtent_.Clone() : null;
      dstExtent_ = other.dstExtent_ != null ? other.dstExtent_.Clone() : null;
      srcOffset_ = other.srcOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CowMergeOperation Clone() {
      return new CowMergeOperation(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::ChromeosUpdateEngine.CowMergeOperation.Types.Type TypeDefaultValue = global::ChromeosUpdateEngine.CowMergeOperation.Types.Type.CowCopy;

    private global::ChromeosUpdateEngine.CowMergeOperation.Types.Type type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.CowMergeOperation.Types.Type Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "src_extent" field.</summary>
    public const int SrcExtentFieldNumber = 2;
    private global::ChromeosUpdateEngine.Extent srcExtent_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent SrcExtent {
      get { return srcExtent_; }
      set {
        srcExtent_ = value;
      }
    }

    /// <summary>Field number for the "dst_extent" field.</summary>
    public const int DstExtentFieldNumber = 3;
    private global::ChromeosUpdateEngine.Extent dstExtent_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent DstExtent {
      get { return dstExtent_; }
      set {
        dstExtent_ = value;
      }
    }

    /// <summary>Field number for the "src_offset" field.</summary>
    public const int SrcOffsetFieldNumber = 4;
    private readonly static uint SrcOffsetDefaultValue = 0;

    private uint srcOffset_;
    /// <summary>
    /// For COW_XOR, source location might be unaligned, so this field is in range
    /// [0, block_size), representing how much should the src_extent shift toward
    /// larger block number. If this field is non-zero, then src_extent will
    /// include 1 extra block in the end, as the merge op actually references the
    /// first |src_offset| bytes of that extra block. For example, if |dst_extent|
    /// is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
    /// Note that |src_extent| contains 1 extra block than the |dst_extent|.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SrcOffset {
      get { if ((_hasBits0 & 2) != 0) { return srcOffset_; } else { return SrcOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        srcOffset_ = value;
      }
    }
    /// <summary>Gets whether the "src_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSrcOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "src_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSrcOffset() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CowMergeOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CowMergeOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (!object.Equals(SrcExtent, other.SrcExtent)) return false;
      if (!object.Equals(DstExtent, other.DstExtent)) return false;
      if (SrcOffset != other.SrcOffset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (srcExtent_ != null) hash ^= SrcExtent.GetHashCode();
      if (dstExtent_ != null) hash ^= DstExtent.GetHashCode();
      if (HasSrcOffset) hash ^= SrcOffset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (srcExtent_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SrcExtent);
      }
      if (dstExtent_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DstExtent);
      }
      if (HasSrcOffset) {
        output.WriteRawTag(32);
        output.WriteUInt32(SrcOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (srcExtent_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SrcExtent);
      }
      if (dstExtent_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DstExtent);
      }
      if (HasSrcOffset) {
        output.WriteRawTag(32);
        output.WriteUInt32(SrcOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (srcExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SrcExtent);
      }
      if (dstExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DstExtent);
      }
      if (HasSrcOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SrcOffset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CowMergeOperation other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.srcExtent_ != null) {
        if (srcExtent_ == null) {
          SrcExtent = new global::ChromeosUpdateEngine.Extent();
        }
        SrcExtent.MergeFrom(other.SrcExtent);
      }
      if (other.dstExtent_ != null) {
        if (dstExtent_ == null) {
          DstExtent = new global::ChromeosUpdateEngine.Extent();
        }
        DstExtent.MergeFrom(other.DstExtent);
      }
      if (other.HasSrcOffset) {
        SrcOffset = other.SrcOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::ChromeosUpdateEngine.CowMergeOperation.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            if (srcExtent_ == null) {
              SrcExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(SrcExtent);
            break;
          }
          case 26: {
            if (dstExtent_ == null) {
              DstExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(DstExtent);
            break;
          }
          case 32: {
            SrcOffset = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::ChromeosUpdateEngine.CowMergeOperation.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            if (srcExtent_ == null) {
              SrcExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(SrcExtent);
            break;
          }
          case 26: {
            if (dstExtent_ == null) {
              DstExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(DstExtent);
            break;
          }
          case 32: {
            SrcOffset = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CowMergeOperation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Type {
        /// <summary>
        /// identical blocks
        /// </summary>
        [pbr::OriginalName("COW_COPY")] CowCopy = 0,
        /// <summary>
        /// used when src/dst blocks are highly similar
        /// </summary>
        [pbr::OriginalName("COW_XOR")] CowXor = 1,
        /// <summary>
        /// Raw replace operation
        /// </summary>
        [pbr::OriginalName("COW_REPLACE")] CowReplace = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes the update to apply to a single partition.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PartitionUpdate : pb::IMessage<PartitionUpdate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PartitionUpdate> _parser = new pb::MessageParser<PartitionUpdate>(() => new PartitionUpdate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PartitionUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionUpdate(PartitionUpdate other) : this() {
      _hasBits0 = other._hasBits0;
      partitionName_ = other.partitionName_;
      runPostinstall_ = other.runPostinstall_;
      postinstallPath_ = other.postinstallPath_;
      filesystemType_ = other.filesystemType_;
      newPartitionSignature_ = other.newPartitionSignature_.Clone();
      oldPartitionInfo_ = other.oldPartitionInfo_ != null ? other.oldPartitionInfo_.Clone() : null;
      newPartitionInfo_ = other.newPartitionInfo_ != null ? other.newPartitionInfo_.Clone() : null;
      operations_ = other.operations_.Clone();
      postinstallOptional_ = other.postinstallOptional_;
      hashTreeDataExtent_ = other.hashTreeDataExtent_ != null ? other.hashTreeDataExtent_.Clone() : null;
      hashTreeExtent_ = other.hashTreeExtent_ != null ? other.hashTreeExtent_.Clone() : null;
      hashTreeAlgorithm_ = other.hashTreeAlgorithm_;
      hashTreeSalt_ = other.hashTreeSalt_;
      fecDataExtent_ = other.fecDataExtent_ != null ? other.fecDataExtent_.Clone() : null;
      fecExtent_ = other.fecExtent_ != null ? other.fecExtent_.Clone() : null;
      fecRoots_ = other.fecRoots_;
      version_ = other.version_;
      mergeOperations_ = other.mergeOperations_.Clone();
      estimateCowSize_ = other.estimateCowSize_;
      estimateOpCountMax_ = other.estimateOpCountMax_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PartitionUpdate Clone() {
      return new PartitionUpdate(this);
    }

    /// <summary>Field number for the "partition_name" field.</summary>
    public const int PartitionNameFieldNumber = 1;
    private readonly static string PartitionNameDefaultValue = "";

    private string partitionName_;
    /// <summary>
    /// A platform-specific name to identify the partition set being updated. For
    /// example, in Chrome OS this could be "ROOT" or "KERNEL".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PartitionName {
      get { return partitionName_ ?? PartitionNameDefaultValue; }
      set {
        partitionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "partition_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPartitionName {
      get { return partitionName_ != null; }
    }
    /// <summary>Clears the value of the "partition_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPartitionName() {
      partitionName_ = null;
    }

    /// <summary>Field number for the "run_postinstall" field.</summary>
    public const int RunPostinstallFieldNumber = 2;
    private readonly static bool RunPostinstallDefaultValue = false;

    private bool runPostinstall_;
    /// <summary>
    /// Whether this partition carries a filesystem with post-install program that
    /// must be run to finalize the update process. See also |postinstall_path| and
    /// |filesystem_type|.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RunPostinstall {
      get { if ((_hasBits0 & 1) != 0) { return runPostinstall_; } else { return RunPostinstallDefaultValue; } }
      set {
        _hasBits0 |= 1;
        runPostinstall_ = value;
      }
    }
    /// <summary>Gets whether the "run_postinstall" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunPostinstall {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "run_postinstall" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunPostinstall() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postinstall_path" field.</summary>
    public const int PostinstallPathFieldNumber = 3;
    private readonly static string PostinstallPathDefaultValue = "";

    private string postinstallPath_;
    /// <summary>
    /// The path of the executable program to run during the post-install step,
    /// relative to the root of this filesystem. If not set, the default "postinst"
    /// will be used. This setting is only used when |run_postinstall| is set and
    /// true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PostinstallPath {
      get { return postinstallPath_ ?? PostinstallPathDefaultValue; }
      set {
        postinstallPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "postinstall_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPostinstallPath {
      get { return postinstallPath_ != null; }
    }
    /// <summary>Clears the value of the "postinstall_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPostinstallPath() {
      postinstallPath_ = null;
    }

    /// <summary>Field number for the "filesystem_type" field.</summary>
    public const int FilesystemTypeFieldNumber = 4;
    private readonly static string FilesystemTypeDefaultValue = "";

    private string filesystemType_;
    /// <summary>
    /// The filesystem type as passed to the mount(2) syscall when mounting the new
    /// filesystem to run the post-install program. If not set, a fixed list of
    /// filesystems will be attempted. This setting is only used if
    /// |run_postinstall| is set and true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FilesystemType {
      get { return filesystemType_ ?? FilesystemTypeDefaultValue; }
      set {
        filesystemType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "filesystem_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilesystemType {
      get { return filesystemType_ != null; }
    }
    /// <summary>Clears the value of the "filesystem_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilesystemType() {
      filesystemType_ = null;
    }

    /// <summary>Field number for the "new_partition_signature" field.</summary>
    public const int NewPartitionSignatureFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Signatures.Types.Signature> _repeated_newPartitionSignature_codec
        = pb::FieldCodec.ForMessage(42, global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> newPartitionSignature_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature>();
    /// <summary>
    /// If present, a list of signatures of the new_partition_info.hash signed with
    /// different keys. If the update_engine daemon requires vendor-signed images
    /// and has its public key installed, one of the signatures should be valid
    /// for /postinstall to run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> NewPartitionSignature {
      get { return newPartitionSignature_; }
    }

    /// <summary>Field number for the "old_partition_info" field.</summary>
    public const int OldPartitionInfoFieldNumber = 6;
    private global::ChromeosUpdateEngine.PartitionInfo oldPartitionInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.PartitionInfo OldPartitionInfo {
      get { return oldPartitionInfo_; }
      set {
        oldPartitionInfo_ = value;
      }
    }

    /// <summary>Field number for the "new_partition_info" field.</summary>
    public const int NewPartitionInfoFieldNumber = 7;
    private global::ChromeosUpdateEngine.PartitionInfo newPartitionInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.PartitionInfo NewPartitionInfo {
      get { return newPartitionInfo_; }
      set {
        newPartitionInfo_ = value;
      }
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.InstallOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(66, global::ChromeosUpdateEngine.InstallOperation.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> operations_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation>();
    /// <summary>
    /// The list of operations to be performed to apply this PartitionUpdate. The
    /// associated operation blobs (in operations[i].data_offset, data_length)
    /// should be stored contiguously and in the same order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> Operations {
      get { return operations_; }
    }

    /// <summary>Field number for the "postinstall_optional" field.</summary>
    public const int PostinstallOptionalFieldNumber = 9;
    private readonly static bool PostinstallOptionalDefaultValue = false;

    private bool postinstallOptional_;
    /// <summary>
    /// Whether a failure in the postinstall step for this partition should be
    /// ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PostinstallOptional {
      get { if ((_hasBits0 & 2) != 0) { return postinstallOptional_; } else { return PostinstallOptionalDefaultValue; } }
      set {
        _hasBits0 |= 2;
        postinstallOptional_ = value;
      }
    }
    /// <summary>Gets whether the "postinstall_optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPostinstallOptional {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "postinstall_optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPostinstallOptional() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "hash_tree_data_extent" field.</summary>
    public const int HashTreeDataExtentFieldNumber = 10;
    private global::ChromeosUpdateEngine.Extent hashTreeDataExtent_;
    /// <summary>
    /// The extent for data covered by verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent HashTreeDataExtent {
      get { return hashTreeDataExtent_; }
      set {
        hashTreeDataExtent_ = value;
      }
    }

    /// <summary>Field number for the "hash_tree_extent" field.</summary>
    public const int HashTreeExtentFieldNumber = 11;
    private global::ChromeosUpdateEngine.Extent hashTreeExtent_;
    /// <summary>
    /// The extent to store verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent HashTreeExtent {
      get { return hashTreeExtent_; }
      set {
        hashTreeExtent_ = value;
      }
    }

    /// <summary>Field number for the "hash_tree_algorithm" field.</summary>
    public const int HashTreeAlgorithmFieldNumber = 12;
    private readonly static string HashTreeAlgorithmDefaultValue = "";

    private string hashTreeAlgorithm_;
    /// <summary>
    /// The hash algorithm used in verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HashTreeAlgorithm {
      get { return hashTreeAlgorithm_ ?? HashTreeAlgorithmDefaultValue; }
      set {
        hashTreeAlgorithm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash_tree_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHashTreeAlgorithm {
      get { return hashTreeAlgorithm_ != null; }
    }
    /// <summary>Clears the value of the "hash_tree_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHashTreeAlgorithm() {
      hashTreeAlgorithm_ = null;
    }

    /// <summary>Field number for the "hash_tree_salt" field.</summary>
    public const int HashTreeSaltFieldNumber = 13;
    private readonly static pb::ByteString HashTreeSaltDefaultValue = pb::ByteString.Empty;

    private pb::ByteString hashTreeSalt_;
    /// <summary>
    /// The salt used for verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString HashTreeSalt {
      get { return hashTreeSalt_ ?? HashTreeSaltDefaultValue; }
      set {
        hashTreeSalt_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash_tree_salt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHashTreeSalt {
      get { return hashTreeSalt_ != null; }
    }
    /// <summary>Clears the value of the "hash_tree_salt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHashTreeSalt() {
      hashTreeSalt_ = null;
    }

    /// <summary>Field number for the "fec_data_extent" field.</summary>
    public const int FecDataExtentFieldNumber = 14;
    private global::ChromeosUpdateEngine.Extent fecDataExtent_;
    /// <summary>
    /// The extent for data covered by FEC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent FecDataExtent {
      get { return fecDataExtent_; }
      set {
        fecDataExtent_ = value;
      }
    }

    /// <summary>Field number for the "fec_extent" field.</summary>
    public const int FecExtentFieldNumber = 15;
    private global::ChromeosUpdateEngine.Extent fecExtent_;
    /// <summary>
    /// The extent to store FEC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.Extent FecExtent {
      get { return fecExtent_; }
      set {
        fecExtent_ = value;
      }
    }

    /// <summary>Field number for the "fec_roots" field.</summary>
    public const int FecRootsFieldNumber = 16;
    private readonly static uint FecRootsDefaultValue = 2;

    private uint fecRoots_;
    /// <summary>
    /// The number of FEC roots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint FecRoots {
      get { if ((_hasBits0 & 4) != 0) { return fecRoots_; } else { return FecRootsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        fecRoots_ = value;
      }
    }
    /// <summary>Gets whether the "fec_roots" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFecRoots {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "fec_roots" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFecRoots() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 17;
    private readonly static string VersionDefaultValue = "";

    private string version_;
    /// <summary>
    /// Per-partition version used for downgrade detection, added
    /// as an effort to support partial updates. For most partitions,
    /// this is the build timestamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Version {
      get { return version_ ?? VersionDefaultValue; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return version_ != null; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      version_ = null;
    }

    /// <summary>Field number for the "merge_operations" field.</summary>
    public const int MergeOperationsFieldNumber = 18;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.CowMergeOperation> _repeated_mergeOperations_codec
        = pb::FieldCodec.ForMessage(146, global::ChromeosUpdateEngine.CowMergeOperation.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.CowMergeOperation> mergeOperations_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.CowMergeOperation>();
    /// <summary>
    /// A sorted list of CowMergeOperation. When writing cow, we can choose to
    /// skip writing the raw bytes for these extents. During snapshot merge, the
    /// bytes will read from the source partitions instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.CowMergeOperation> MergeOperations {
      get { return mergeOperations_; }
    }

    /// <summary>Field number for the "estimate_cow_size" field.</summary>
    public const int EstimateCowSizeFieldNumber = 19;
    private readonly static ulong EstimateCowSizeDefaultValue = 0UL;

    private ulong estimateCowSize_;
    /// <summary>
    /// Estimated size for COW image. This is used by libsnapshot
    /// as a hint. If set to 0, libsnapshot should use alternative
    /// methods for estimating size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong EstimateCowSize {
      get { if ((_hasBits0 & 8) != 0) { return estimateCowSize_; } else { return EstimateCowSizeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        estimateCowSize_ = value;
      }
    }
    /// <summary>Gets whether the "estimate_cow_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimateCowSize {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "estimate_cow_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimateCowSize() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "estimate_op_count_max" field.</summary>
    public const int EstimateOpCountMaxFieldNumber = 20;
    private readonly static ulong EstimateOpCountMaxDefaultValue = 0UL;

    private ulong estimateOpCountMax_;
    /// <summary>
    /// Information about the cow used by Cow Writer to specify
    /// number of cow operations to be written
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong EstimateOpCountMax {
      get { if ((_hasBits0 & 16) != 0) { return estimateOpCountMax_; } else { return EstimateOpCountMaxDefaultValue; } }
      set {
        _hasBits0 |= 16;
        estimateOpCountMax_ = value;
      }
    }
    /// <summary>Gets whether the "estimate_op_count_max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimateOpCountMax {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "estimate_op_count_max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimateOpCountMax() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PartitionUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PartitionUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PartitionName != other.PartitionName) return false;
      if (RunPostinstall != other.RunPostinstall) return false;
      if (PostinstallPath != other.PostinstallPath) return false;
      if (FilesystemType != other.FilesystemType) return false;
      if(!newPartitionSignature_.Equals(other.newPartitionSignature_)) return false;
      if (!object.Equals(OldPartitionInfo, other.OldPartitionInfo)) return false;
      if (!object.Equals(NewPartitionInfo, other.NewPartitionInfo)) return false;
      if(!operations_.Equals(other.operations_)) return false;
      if (PostinstallOptional != other.PostinstallOptional) return false;
      if (!object.Equals(HashTreeDataExtent, other.HashTreeDataExtent)) return false;
      if (!object.Equals(HashTreeExtent, other.HashTreeExtent)) return false;
      if (HashTreeAlgorithm != other.HashTreeAlgorithm) return false;
      if (HashTreeSalt != other.HashTreeSalt) return false;
      if (!object.Equals(FecDataExtent, other.FecDataExtent)) return false;
      if (!object.Equals(FecExtent, other.FecExtent)) return false;
      if (FecRoots != other.FecRoots) return false;
      if (Version != other.Version) return false;
      if(!mergeOperations_.Equals(other.mergeOperations_)) return false;
      if (EstimateCowSize != other.EstimateCowSize) return false;
      if (EstimateOpCountMax != other.EstimateOpCountMax) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPartitionName) hash ^= PartitionName.GetHashCode();
      if (HasRunPostinstall) hash ^= RunPostinstall.GetHashCode();
      if (HasPostinstallPath) hash ^= PostinstallPath.GetHashCode();
      if (HasFilesystemType) hash ^= FilesystemType.GetHashCode();
      hash ^= newPartitionSignature_.GetHashCode();
      if (oldPartitionInfo_ != null) hash ^= OldPartitionInfo.GetHashCode();
      if (newPartitionInfo_ != null) hash ^= NewPartitionInfo.GetHashCode();
      hash ^= operations_.GetHashCode();
      if (HasPostinstallOptional) hash ^= PostinstallOptional.GetHashCode();
      if (hashTreeDataExtent_ != null) hash ^= HashTreeDataExtent.GetHashCode();
      if (hashTreeExtent_ != null) hash ^= HashTreeExtent.GetHashCode();
      if (HasHashTreeAlgorithm) hash ^= HashTreeAlgorithm.GetHashCode();
      if (HasHashTreeSalt) hash ^= HashTreeSalt.GetHashCode();
      if (fecDataExtent_ != null) hash ^= FecDataExtent.GetHashCode();
      if (fecExtent_ != null) hash ^= FecExtent.GetHashCode();
      if (HasFecRoots) hash ^= FecRoots.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      hash ^= mergeOperations_.GetHashCode();
      if (HasEstimateCowSize) hash ^= EstimateCowSize.GetHashCode();
      if (HasEstimateOpCountMax) hash ^= EstimateOpCountMax.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPartitionName) {
        output.WriteRawTag(10);
        output.WriteString(PartitionName);
      }
      if (HasRunPostinstall) {
        output.WriteRawTag(16);
        output.WriteBool(RunPostinstall);
      }
      if (HasPostinstallPath) {
        output.WriteRawTag(26);
        output.WriteString(PostinstallPath);
      }
      if (HasFilesystemType) {
        output.WriteRawTag(34);
        output.WriteString(FilesystemType);
      }
      newPartitionSignature_.WriteTo(output, _repeated_newPartitionSignature_codec);
      if (oldPartitionInfo_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OldPartitionInfo);
      }
      if (newPartitionInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NewPartitionInfo);
      }
      operations_.WriteTo(output, _repeated_operations_codec);
      if (HasPostinstallOptional) {
        output.WriteRawTag(72);
        output.WriteBool(PostinstallOptional);
      }
      if (hashTreeDataExtent_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HashTreeDataExtent);
      }
      if (hashTreeExtent_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(HashTreeExtent);
      }
      if (HasHashTreeAlgorithm) {
        output.WriteRawTag(98);
        output.WriteString(HashTreeAlgorithm);
      }
      if (HasHashTreeSalt) {
        output.WriteRawTag(106);
        output.WriteBytes(HashTreeSalt);
      }
      if (fecDataExtent_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FecDataExtent);
      }
      if (fecExtent_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(FecExtent);
      }
      if (HasFecRoots) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(FecRoots);
      }
      if (HasVersion) {
        output.WriteRawTag(138, 1);
        output.WriteString(Version);
      }
      mergeOperations_.WriteTo(output, _repeated_mergeOperations_codec);
      if (HasEstimateCowSize) {
        output.WriteRawTag(152, 1);
        output.WriteUInt64(EstimateCowSize);
      }
      if (HasEstimateOpCountMax) {
        output.WriteRawTag(160, 1);
        output.WriteUInt64(EstimateOpCountMax);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPartitionName) {
        output.WriteRawTag(10);
        output.WriteString(PartitionName);
      }
      if (HasRunPostinstall) {
        output.WriteRawTag(16);
        output.WriteBool(RunPostinstall);
      }
      if (HasPostinstallPath) {
        output.WriteRawTag(26);
        output.WriteString(PostinstallPath);
      }
      if (HasFilesystemType) {
        output.WriteRawTag(34);
        output.WriteString(FilesystemType);
      }
      newPartitionSignature_.WriteTo(ref output, _repeated_newPartitionSignature_codec);
      if (oldPartitionInfo_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OldPartitionInfo);
      }
      if (newPartitionInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NewPartitionInfo);
      }
      operations_.WriteTo(ref output, _repeated_operations_codec);
      if (HasPostinstallOptional) {
        output.WriteRawTag(72);
        output.WriteBool(PostinstallOptional);
      }
      if (hashTreeDataExtent_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HashTreeDataExtent);
      }
      if (hashTreeExtent_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(HashTreeExtent);
      }
      if (HasHashTreeAlgorithm) {
        output.WriteRawTag(98);
        output.WriteString(HashTreeAlgorithm);
      }
      if (HasHashTreeSalt) {
        output.WriteRawTag(106);
        output.WriteBytes(HashTreeSalt);
      }
      if (fecDataExtent_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FecDataExtent);
      }
      if (fecExtent_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(FecExtent);
      }
      if (HasFecRoots) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(FecRoots);
      }
      if (HasVersion) {
        output.WriteRawTag(138, 1);
        output.WriteString(Version);
      }
      mergeOperations_.WriteTo(ref output, _repeated_mergeOperations_codec);
      if (HasEstimateCowSize) {
        output.WriteRawTag(152, 1);
        output.WriteUInt64(EstimateCowSize);
      }
      if (HasEstimateOpCountMax) {
        output.WriteRawTag(160, 1);
        output.WriteUInt64(EstimateOpCountMax);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPartitionName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PartitionName);
      }
      if (HasRunPostinstall) {
        size += 1 + 1;
      }
      if (HasPostinstallPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PostinstallPath);
      }
      if (HasFilesystemType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilesystemType);
      }
      size += newPartitionSignature_.CalculateSize(_repeated_newPartitionSignature_codec);
      if (oldPartitionInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldPartitionInfo);
      }
      if (newPartitionInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewPartitionInfo);
      }
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (HasPostinstallOptional) {
        size += 1 + 1;
      }
      if (hashTreeDataExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HashTreeDataExtent);
      }
      if (hashTreeExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HashTreeExtent);
      }
      if (HasHashTreeAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HashTreeAlgorithm);
      }
      if (HasHashTreeSalt) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(HashTreeSalt);
      }
      if (fecDataExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FecDataExtent);
      }
      if (fecExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FecExtent);
      }
      if (HasFecRoots) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(FecRoots);
      }
      if (HasVersion) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      size += mergeOperations_.CalculateSize(_repeated_mergeOperations_codec);
      if (HasEstimateCowSize) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(EstimateCowSize);
      }
      if (HasEstimateOpCountMax) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(EstimateOpCountMax);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PartitionUpdate other) {
      if (other == null) {
        return;
      }
      if (other.HasPartitionName) {
        PartitionName = other.PartitionName;
      }
      if (other.HasRunPostinstall) {
        RunPostinstall = other.RunPostinstall;
      }
      if (other.HasPostinstallPath) {
        PostinstallPath = other.PostinstallPath;
      }
      if (other.HasFilesystemType) {
        FilesystemType = other.FilesystemType;
      }
      newPartitionSignature_.Add(other.newPartitionSignature_);
      if (other.oldPartitionInfo_ != null) {
        if (oldPartitionInfo_ == null) {
          OldPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        OldPartitionInfo.MergeFrom(other.OldPartitionInfo);
      }
      if (other.newPartitionInfo_ != null) {
        if (newPartitionInfo_ == null) {
          NewPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        NewPartitionInfo.MergeFrom(other.NewPartitionInfo);
      }
      operations_.Add(other.operations_);
      if (other.HasPostinstallOptional) {
        PostinstallOptional = other.PostinstallOptional;
      }
      if (other.hashTreeDataExtent_ != null) {
        if (hashTreeDataExtent_ == null) {
          HashTreeDataExtent = new global::ChromeosUpdateEngine.Extent();
        }
        HashTreeDataExtent.MergeFrom(other.HashTreeDataExtent);
      }
      if (other.hashTreeExtent_ != null) {
        if (hashTreeExtent_ == null) {
          HashTreeExtent = new global::ChromeosUpdateEngine.Extent();
        }
        HashTreeExtent.MergeFrom(other.HashTreeExtent);
      }
      if (other.HasHashTreeAlgorithm) {
        HashTreeAlgorithm = other.HashTreeAlgorithm;
      }
      if (other.HasHashTreeSalt) {
        HashTreeSalt = other.HashTreeSalt;
      }
      if (other.fecDataExtent_ != null) {
        if (fecDataExtent_ == null) {
          FecDataExtent = new global::ChromeosUpdateEngine.Extent();
        }
        FecDataExtent.MergeFrom(other.FecDataExtent);
      }
      if (other.fecExtent_ != null) {
        if (fecExtent_ == null) {
          FecExtent = new global::ChromeosUpdateEngine.Extent();
        }
        FecExtent.MergeFrom(other.FecExtent);
      }
      if (other.HasFecRoots) {
        FecRoots = other.FecRoots;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      mergeOperations_.Add(other.mergeOperations_);
      if (other.HasEstimateCowSize) {
        EstimateCowSize = other.EstimateCowSize;
      }
      if (other.HasEstimateOpCountMax) {
        EstimateOpCountMax = other.EstimateOpCountMax;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PartitionName = input.ReadString();
            break;
          }
          case 16: {
            RunPostinstall = input.ReadBool();
            break;
          }
          case 26: {
            PostinstallPath = input.ReadString();
            break;
          }
          case 34: {
            FilesystemType = input.ReadString();
            break;
          }
          case 42: {
            newPartitionSignature_.AddEntriesFrom(input, _repeated_newPartitionSignature_codec);
            break;
          }
          case 50: {
            if (oldPartitionInfo_ == null) {
              OldPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(OldPartitionInfo);
            break;
          }
          case 58: {
            if (newPartitionInfo_ == null) {
              NewPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(NewPartitionInfo);
            break;
          }
          case 66: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
          case 72: {
            PostinstallOptional = input.ReadBool();
            break;
          }
          case 82: {
            if (hashTreeDataExtent_ == null) {
              HashTreeDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeDataExtent);
            break;
          }
          case 90: {
            if (hashTreeExtent_ == null) {
              HashTreeExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeExtent);
            break;
          }
          case 98: {
            HashTreeAlgorithm = input.ReadString();
            break;
          }
          case 106: {
            HashTreeSalt = input.ReadBytes();
            break;
          }
          case 114: {
            if (fecDataExtent_ == null) {
              FecDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecDataExtent);
            break;
          }
          case 122: {
            if (fecExtent_ == null) {
              FecExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecExtent);
            break;
          }
          case 128: {
            FecRoots = input.ReadUInt32();
            break;
          }
          case 138: {
            Version = input.ReadString();
            break;
          }
          case 146: {
            mergeOperations_.AddEntriesFrom(input, _repeated_mergeOperations_codec);
            break;
          }
          case 152: {
            EstimateCowSize = input.ReadUInt64();
            break;
          }
          case 160: {
            EstimateOpCountMax = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PartitionName = input.ReadString();
            break;
          }
          case 16: {
            RunPostinstall = input.ReadBool();
            break;
          }
          case 26: {
            PostinstallPath = input.ReadString();
            break;
          }
          case 34: {
            FilesystemType = input.ReadString();
            break;
          }
          case 42: {
            newPartitionSignature_.AddEntriesFrom(ref input, _repeated_newPartitionSignature_codec);
            break;
          }
          case 50: {
            if (oldPartitionInfo_ == null) {
              OldPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(OldPartitionInfo);
            break;
          }
          case 58: {
            if (newPartitionInfo_ == null) {
              NewPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(NewPartitionInfo);
            break;
          }
          case 66: {
            operations_.AddEntriesFrom(ref input, _repeated_operations_codec);
            break;
          }
          case 72: {
            PostinstallOptional = input.ReadBool();
            break;
          }
          case 82: {
            if (hashTreeDataExtent_ == null) {
              HashTreeDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeDataExtent);
            break;
          }
          case 90: {
            if (hashTreeExtent_ == null) {
              HashTreeExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeExtent);
            break;
          }
          case 98: {
            HashTreeAlgorithm = input.ReadString();
            break;
          }
          case 106: {
            HashTreeSalt = input.ReadBytes();
            break;
          }
          case 114: {
            if (fecDataExtent_ == null) {
              FecDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecDataExtent);
            break;
          }
          case 122: {
            if (fecExtent_ == null) {
              FecExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecExtent);
            break;
          }
          case 128: {
            FecRoots = input.ReadUInt32();
            break;
          }
          case 138: {
            Version = input.ReadString();
            break;
          }
          case 146: {
            mergeOperations_.AddEntriesFrom(ref input, _repeated_mergeOperations_codec);
            break;
          }
          case 152: {
            EstimateCowSize = input.ReadUInt64();
            break;
          }
          case 160: {
            EstimateOpCountMax = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DynamicPartitionGroup : pb::IMessage<DynamicPartitionGroup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DynamicPartitionGroup> _parser = new pb::MessageParser<DynamicPartitionGroup>(() => new DynamicPartitionGroup());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DynamicPartitionGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionGroup(DynamicPartitionGroup other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      size_ = other.size_;
      partitionNames_ = other.partitionNames_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionGroup Clone() {
      return new DynamicPartitionGroup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 2;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    /// <summary>
    /// Maximum size of the group. The sum of sizes of all partitions in the group
    /// must not exceed the maximum size of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "partition_names" field.</summary>
    public const int PartitionNamesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_partitionNames_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> partitionNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of partitions that belong to the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> PartitionNames {
      get { return partitionNames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DynamicPartitionGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DynamicPartitionGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Size != other.Size) return false;
      if(!partitionNames_.Equals(other.partitionNames_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasSize) hash ^= Size.GetHashCode();
      hash ^= partitionNames_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      partitionNames_.WriteTo(output, _repeated_partitionNames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      partitionNames_.WriteTo(ref output, _repeated_partitionNames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      size += partitionNames_.CalculateSize(_repeated_partitionNames_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DynamicPartitionGroup other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      partitionNames_.Add(other.partitionNames_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 26: {
            partitionNames_.AddEntriesFrom(input, _repeated_partitionNames_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 26: {
            partitionNames_.AddEntriesFrom(ref input, _repeated_partitionNames_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class VABCFeatureSet : pb::IMessage<VABCFeatureSet>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VABCFeatureSet> _parser = new pb::MessageParser<VABCFeatureSet>(() => new VABCFeatureSet());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VABCFeatureSet> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VABCFeatureSet() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VABCFeatureSet(VABCFeatureSet other) : this() {
      _hasBits0 = other._hasBits0;
      threaded_ = other.threaded_;
      batchWrites_ = other.batchWrites_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VABCFeatureSet Clone() {
      return new VABCFeatureSet(this);
    }

    /// <summary>Field number for the "threaded" field.</summary>
    public const int ThreadedFieldNumber = 1;
    private readonly static bool ThreadedDefaultValue = false;

    private bool threaded_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Threaded {
      get { if ((_hasBits0 & 1) != 0) { return threaded_; } else { return ThreadedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        threaded_ = value;
      }
    }
    /// <summary>Gets whether the "threaded" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasThreaded {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "threaded" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearThreaded() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "batch_writes" field.</summary>
    public const int BatchWritesFieldNumber = 2;
    private readonly static bool BatchWritesDefaultValue = false;

    private bool batchWrites_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool BatchWrites {
      get { if ((_hasBits0 & 2) != 0) { return batchWrites_; } else { return BatchWritesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        batchWrites_ = value;
      }
    }
    /// <summary>Gets whether the "batch_writes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBatchWrites {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "batch_writes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBatchWrites() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VABCFeatureSet);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VABCFeatureSet other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Threaded != other.Threaded) return false;
      if (BatchWrites != other.BatchWrites) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasThreaded) hash ^= Threaded.GetHashCode();
      if (HasBatchWrites) hash ^= BatchWrites.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasThreaded) {
        output.WriteRawTag(8);
        output.WriteBool(Threaded);
      }
      if (HasBatchWrites) {
        output.WriteRawTag(16);
        output.WriteBool(BatchWrites);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasThreaded) {
        output.WriteRawTag(8);
        output.WriteBool(Threaded);
      }
      if (HasBatchWrites) {
        output.WriteRawTag(16);
        output.WriteBool(BatchWrites);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasThreaded) {
        size += 1 + 1;
      }
      if (HasBatchWrites) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VABCFeatureSet other) {
      if (other == null) {
        return;
      }
      if (other.HasThreaded) {
        Threaded = other.Threaded;
      }
      if (other.HasBatchWrites) {
        BatchWrites = other.BatchWrites;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Threaded = input.ReadBool();
            break;
          }
          case 16: {
            BatchWrites = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Threaded = input.ReadBool();
            break;
          }
          case 16: {
            BatchWrites = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Metadata related to all dynamic partitions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DynamicPartitionMetadata : pb::IMessage<DynamicPartitionMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DynamicPartitionMetadata> _parser = new pb::MessageParser<DynamicPartitionMetadata>(() => new DynamicPartitionMetadata());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DynamicPartitionMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionMetadata(DynamicPartitionMetadata other) : this() {
      _hasBits0 = other._hasBits0;
      groups_ = other.groups_.Clone();
      snapshotEnabled_ = other.snapshotEnabled_;
      vabcEnabled_ = other.vabcEnabled_;
      vabcCompressionParam_ = other.vabcCompressionParam_;
      cowVersion_ = other.cowVersion_;
      vabcFeatureSet_ = other.vabcFeatureSet_ != null ? other.vabcFeatureSet_.Clone() : null;
      compressionFactor_ = other.compressionFactor_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DynamicPartitionMetadata Clone() {
      return new DynamicPartitionMetadata(this);
    }

    /// <summary>Field number for the "groups" field.</summary>
    public const int GroupsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.DynamicPartitionGroup> _repeated_groups_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.DynamicPartitionGroup.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup> groups_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup>();
    /// <summary>
    /// All updatable groups present in |partitions| of this DeltaArchiveManifest.
    /// - If an updatable group is on the device but not in the manifest, it is
    ///   not updated. Hence, the group will not be resized, and partitions cannot
    ///   be added to or removed from the group.
    /// - If an updatable group is in the manifest but not on the device, the group
    ///   is added to the device.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup> Groups {
      get { return groups_; }
    }

    /// <summary>Field number for the "snapshot_enabled" field.</summary>
    public const int SnapshotEnabledFieldNumber = 2;
    private readonly static bool SnapshotEnabledDefaultValue = false;

    private bool snapshotEnabled_;
    /// <summary>
    /// Whether dynamic partitions have snapshots during the update. If this is
    /// set to true, the update_engine daemon creates snapshots for all dynamic
    /// partitions if possible. If this is unset, the update_engine daemon MUST
    /// NOT create snapshots for dynamic partitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SnapshotEnabled {
      get { if ((_hasBits0 & 1) != 0) { return snapshotEnabled_; } else { return SnapshotEnabledDefaultValue; } }
      set {
        _hasBits0 |= 1;
        snapshotEnabled_ = value;
      }
    }
    /// <summary>Gets whether the "snapshot_enabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSnapshotEnabled {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "snapshot_enabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSnapshotEnabled() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "vabc_enabled" field.</summary>
    public const int VabcEnabledFieldNumber = 3;
    private readonly static bool VabcEnabledDefaultValue = false;

    private bool vabcEnabled_;
    /// <summary>
    /// If this is set to false, update_engine should not use VABC regardless. If
    /// this is set to true, update_engine may choose to use VABC if device
    /// supports it, but not guaranteed.
    /// VABC stands for Virtual AB Compression
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool VabcEnabled {
      get { if ((_hasBits0 & 2) != 0) { return vabcEnabled_; } else { return VabcEnabledDefaultValue; } }
      set {
        _hasBits0 |= 2;
        vabcEnabled_ = value;
      }
    }
    /// <summary>Gets whether the "vabc_enabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVabcEnabled {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "vabc_enabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVabcEnabled() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "vabc_compression_param" field.</summary>
    public const int VabcCompressionParamFieldNumber = 4;
    private readonly static string VabcCompressionParamDefaultValue = "";

    private string vabcCompressionParam_;
    /// <summary>
    /// The compression algorithm used by VABC. Available ones are "gz", "brotli".
    /// See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
    /// as this parameter is ultimated forwarded to libsnapshot's CowWriter
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VabcCompressionParam {
      get { return vabcCompressionParam_ ?? VabcCompressionParamDefaultValue; }
      set {
        vabcCompressionParam_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "vabc_compression_param" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVabcCompressionParam {
      get { return vabcCompressionParam_ != null; }
    }
    /// <summary>Clears the value of the "vabc_compression_param" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVabcCompressionParam() {
      vabcCompressionParam_ = null;
    }

    /// <summary>Field number for the "cow_version" field.</summary>
    public const int CowVersionFieldNumber = 5;
    private readonly static uint CowVersionDefaultValue = 0;

    private uint cowVersion_;
    /// <summary>
    /// COW version used by VABC. The represents the major version in the COW
    /// header
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint CowVersion {
      get { if ((_hasBits0 & 4) != 0) { return cowVersion_; } else { return CowVersionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        cowVersion_ = value;
      }
    }
    /// <summary>Gets whether the "cow_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCowVersion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "cow_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCowVersion() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "vabc_feature_set" field.</summary>
    public const int VabcFeatureSetFieldNumber = 6;
    private global::ChromeosUpdateEngine.VABCFeatureSet vabcFeatureSet_;
    /// <summary>
    /// A collection of knobs to tune Virtual AB Compression
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.VABCFeatureSet VabcFeatureSet {
      get { return vabcFeatureSet_; }
      set {
        vabcFeatureSet_ = value;
      }
    }

    /// <summary>Field number for the "compression_factor" field.</summary>
    public const int CompressionFactorFieldNumber = 7;
    private readonly static ulong CompressionFactorDefaultValue = 0UL;

    private ulong compressionFactor_;
    /// <summary>
    /// Max bytes to be compressed at once during ota. Options: 4k, 8k, 16k, 32k,
    /// 64k, 128k
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong CompressionFactor {
      get { if ((_hasBits0 & 8) != 0) { return compressionFactor_; } else { return CompressionFactorDefaultValue; } }
      set {
        _hasBits0 |= 8;
        compressionFactor_ = value;
      }
    }
    /// <summary>Gets whether the "compression_factor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCompressionFactor {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "compression_factor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCompressionFactor() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DynamicPartitionMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DynamicPartitionMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!groups_.Equals(other.groups_)) return false;
      if (SnapshotEnabled != other.SnapshotEnabled) return false;
      if (VabcEnabled != other.VabcEnabled) return false;
      if (VabcCompressionParam != other.VabcCompressionParam) return false;
      if (CowVersion != other.CowVersion) return false;
      if (!object.Equals(VabcFeatureSet, other.VabcFeatureSet)) return false;
      if (CompressionFactor != other.CompressionFactor) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= groups_.GetHashCode();
      if (HasSnapshotEnabled) hash ^= SnapshotEnabled.GetHashCode();
      if (HasVabcEnabled) hash ^= VabcEnabled.GetHashCode();
      if (HasVabcCompressionParam) hash ^= VabcCompressionParam.GetHashCode();
      if (HasCowVersion) hash ^= CowVersion.GetHashCode();
      if (vabcFeatureSet_ != null) hash ^= VabcFeatureSet.GetHashCode();
      if (HasCompressionFactor) hash ^= CompressionFactor.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      groups_.WriteTo(output, _repeated_groups_codec);
      if (HasSnapshotEnabled) {
        output.WriteRawTag(16);
        output.WriteBool(SnapshotEnabled);
      }
      if (HasVabcEnabled) {
        output.WriteRawTag(24);
        output.WriteBool(VabcEnabled);
      }
      if (HasVabcCompressionParam) {
        output.WriteRawTag(34);
        output.WriteString(VabcCompressionParam);
      }
      if (HasCowVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(CowVersion);
      }
      if (vabcFeatureSet_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VabcFeatureSet);
      }
      if (HasCompressionFactor) {
        output.WriteRawTag(56);
        output.WriteUInt64(CompressionFactor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      groups_.WriteTo(ref output, _repeated_groups_codec);
      if (HasSnapshotEnabled) {
        output.WriteRawTag(16);
        output.WriteBool(SnapshotEnabled);
      }
      if (HasVabcEnabled) {
        output.WriteRawTag(24);
        output.WriteBool(VabcEnabled);
      }
      if (HasVabcCompressionParam) {
        output.WriteRawTag(34);
        output.WriteString(VabcCompressionParam);
      }
      if (HasCowVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(CowVersion);
      }
      if (vabcFeatureSet_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VabcFeatureSet);
      }
      if (HasCompressionFactor) {
        output.WriteRawTag(56);
        output.WriteUInt64(CompressionFactor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += groups_.CalculateSize(_repeated_groups_codec);
      if (HasSnapshotEnabled) {
        size += 1 + 1;
      }
      if (HasVabcEnabled) {
        size += 1 + 1;
      }
      if (HasVabcCompressionParam) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VabcCompressionParam);
      }
      if (HasCowVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CowVersion);
      }
      if (vabcFeatureSet_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VabcFeatureSet);
      }
      if (HasCompressionFactor) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(CompressionFactor);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DynamicPartitionMetadata other) {
      if (other == null) {
        return;
      }
      groups_.Add(other.groups_);
      if (other.HasSnapshotEnabled) {
        SnapshotEnabled = other.SnapshotEnabled;
      }
      if (other.HasVabcEnabled) {
        VabcEnabled = other.VabcEnabled;
      }
      if (other.HasVabcCompressionParam) {
        VabcCompressionParam = other.VabcCompressionParam;
      }
      if (other.HasCowVersion) {
        CowVersion = other.CowVersion;
      }
      if (other.vabcFeatureSet_ != null) {
        if (vabcFeatureSet_ == null) {
          VabcFeatureSet = new global::ChromeosUpdateEngine.VABCFeatureSet();
        }
        VabcFeatureSet.MergeFrom(other.VabcFeatureSet);
      }
      if (other.HasCompressionFactor) {
        CompressionFactor = other.CompressionFactor;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            groups_.AddEntriesFrom(input, _repeated_groups_codec);
            break;
          }
          case 16: {
            SnapshotEnabled = input.ReadBool();
            break;
          }
          case 24: {
            VabcEnabled = input.ReadBool();
            break;
          }
          case 34: {
            VabcCompressionParam = input.ReadString();
            break;
          }
          case 40: {
            CowVersion = input.ReadUInt32();
            break;
          }
          case 50: {
            if (vabcFeatureSet_ == null) {
              VabcFeatureSet = new global::ChromeosUpdateEngine.VABCFeatureSet();
            }
            input.ReadMessage(VabcFeatureSet);
            break;
          }
          case 56: {
            CompressionFactor = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            groups_.AddEntriesFrom(ref input, _repeated_groups_codec);
            break;
          }
          case 16: {
            SnapshotEnabled = input.ReadBool();
            break;
          }
          case 24: {
            VabcEnabled = input.ReadBool();
            break;
          }
          case 34: {
            VabcCompressionParam = input.ReadString();
            break;
          }
          case 40: {
            CowVersion = input.ReadUInt32();
            break;
          }
          case 50: {
            if (vabcFeatureSet_ == null) {
              VabcFeatureSet = new global::ChromeosUpdateEngine.VABCFeatureSet();
            }
            input.ReadMessage(VabcFeatureSet);
            break;
          }
          case 56: {
            CompressionFactor = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Definition has been duplicated from
  /// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ApexInfo : pb::IMessage<ApexInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApexInfo> _parser = new pb::MessageParser<ApexInfo>(() => new ApexInfo());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ApexInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexInfo(ApexInfo other) : this() {
      _hasBits0 = other._hasBits0;
      packageName_ = other.packageName_;
      version_ = other.version_;
      isCompressed_ = other.isCompressed_;
      decompressedSize_ = other.decompressedSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexInfo Clone() {
      return new ApexInfo(this);
    }

    /// <summary>Field number for the "package_name" field.</summary>
    public const int PackageNameFieldNumber = 1;
    private readonly static string PackageNameDefaultValue = "";

    private string packageName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PackageName {
      get { return packageName_ ?? PackageNameDefaultValue; }
      set {
        packageName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "package_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPackageName {
      get { return packageName_ != null; }
    }
    /// <summary>Clears the value of the "package_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPackageName() {
      packageName_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private readonly static long VersionDefaultValue = 0L;

    private long version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Version {
      get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "is_compressed" field.</summary>
    public const int IsCompressedFieldNumber = 3;
    private readonly static bool IsCompressedDefaultValue = false;

    private bool isCompressed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsCompressed {
      get { if ((_hasBits0 & 2) != 0) { return isCompressed_; } else { return IsCompressedDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isCompressed_ = value;
      }
    }
    /// <summary>Gets whether the "is_compressed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsCompressed {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_compressed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsCompressed() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "decompressed_size" field.</summary>
    public const int DecompressedSizeFieldNumber = 4;
    private readonly static long DecompressedSizeDefaultValue = 0L;

    private long decompressedSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long DecompressedSize {
      get { if ((_hasBits0 & 4) != 0) { return decompressedSize_; } else { return DecompressedSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        decompressedSize_ = value;
      }
    }
    /// <summary>Gets whether the "decompressed_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDecompressedSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "decompressed_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDecompressedSize() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ApexInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ApexInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PackageName != other.PackageName) return false;
      if (Version != other.Version) return false;
      if (IsCompressed != other.IsCompressed) return false;
      if (DecompressedSize != other.DecompressedSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPackageName) hash ^= PackageName.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasIsCompressed) hash ^= IsCompressed.GetHashCode();
      if (HasDecompressedSize) hash ^= DecompressedSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPackageName) {
        output.WriteRawTag(10);
        output.WriteString(PackageName);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteInt64(Version);
      }
      if (HasIsCompressed) {
        output.WriteRawTag(24);
        output.WriteBool(IsCompressed);
      }
      if (HasDecompressedSize) {
        output.WriteRawTag(32);
        output.WriteInt64(DecompressedSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPackageName) {
        output.WriteRawTag(10);
        output.WriteString(PackageName);
      }
      if (HasVersion) {
        output.WriteRawTag(16);
        output.WriteInt64(Version);
      }
      if (HasIsCompressed) {
        output.WriteRawTag(24);
        output.WriteBool(IsCompressed);
      }
      if (HasDecompressedSize) {
        output.WriteRawTag(32);
        output.WriteInt64(DecompressedSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPackageName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PackageName);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Version);
      }
      if (HasIsCompressed) {
        size += 1 + 1;
      }
      if (HasDecompressedSize) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DecompressedSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ApexInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasPackageName) {
        PackageName = other.PackageName;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasIsCompressed) {
        IsCompressed = other.IsCompressed;
      }
      if (other.HasDecompressedSize) {
        DecompressedSize = other.DecompressedSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PackageName = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt64();
            break;
          }
          case 24: {
            IsCompressed = input.ReadBool();
            break;
          }
          case 32: {
            DecompressedSize = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PackageName = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt64();
            break;
          }
          case 24: {
            IsCompressed = input.ReadBool();
            break;
          }
          case 32: {
            DecompressedSize = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Definition has been duplicated from
  /// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ApexMetadata : pb::IMessage<ApexMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApexMetadata> _parser = new pb::MessageParser<ApexMetadata>(() => new ApexMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ApexMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexMetadata(ApexMetadata other) : this() {
      apexInfo_ = other.apexInfo_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApexMetadata Clone() {
      return new ApexMetadata(this);
    }

    /// <summary>Field number for the "apex_info" field.</summary>
    public const int ApexInfoFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.ApexInfo> _repeated_apexInfo_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.ApexInfo.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo> apexInfo_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo> ApexInfo {
      get { return apexInfo_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ApexMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ApexMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!apexInfo_.Equals(other.apexInfo_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= apexInfo_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      apexInfo_.WriteTo(output, _repeated_apexInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      apexInfo_.WriteTo(ref output, _repeated_apexInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += apexInfo_.CalculateSize(_repeated_apexInfo_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ApexMetadata other) {
      if (other == null) {
        return;
      }
      apexInfo_.Add(other.apexInfo_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            apexInfo_.AddEntriesFrom(input, _repeated_apexInfo_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            apexInfo_.AddEntriesFrom(ref input, _repeated_apexInfo_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DeltaArchiveManifest : pb::IMessage<DeltaArchiveManifest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeltaArchiveManifest> _parser = new pb::MessageParser<DeltaArchiveManifest>(() => new DeltaArchiveManifest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DeltaArchiveManifest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeltaArchiveManifest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeltaArchiveManifest(DeltaArchiveManifest other) : this() {
      _hasBits0 = other._hasBits0;
      blockSize_ = other.blockSize_;
      signaturesOffset_ = other.signaturesOffset_;
      signaturesSize_ = other.signaturesSize_;
      minorVersion_ = other.minorVersion_;
      partitions_ = other.partitions_.Clone();
      maxTimestamp_ = other.maxTimestamp_;
      dynamicPartitionMetadata_ = other.dynamicPartitionMetadata_ != null ? other.dynamicPartitionMetadata_.Clone() : null;
      partialUpdate_ = other.partialUpdate_;
      apexInfo_ = other.apexInfo_.Clone();
      securityPatchLevel_ = other.securityPatchLevel_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeltaArchiveManifest Clone() {
      return new DeltaArchiveManifest(this);
    }

    /// <summary>Field number for the "block_size" field.</summary>
    public const int BlockSizeFieldNumber = 3;
    private readonly static uint BlockSizeDefaultValue = 4096;

    private uint blockSize_;
    /// <summary>
    /// (At time of writing) usually 4096
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint BlockSize {
      get { if ((_hasBits0 & 1) != 0) { return blockSize_; } else { return BlockSizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        blockSize_ = value;
      }
    }
    /// <summary>Gets whether the "block_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBlockSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "block_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBlockSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "signatures_offset" field.</summary>
    public const int SignaturesOffsetFieldNumber = 4;
    private readonly static ulong SignaturesOffsetDefaultValue = 0UL;

    private ulong signaturesOffset_;
    /// <summary>
    /// If signatures are present, the offset into the blobs, generally
    /// tacked onto the end of the file, and the length. We use an offset
    /// rather than a bool to allow for more flexibility in future file formats.
    /// If either is absent, it means signatures aren't supported in this
    /// file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SignaturesOffset {
      get { if ((_hasBits0 & 2) != 0) { return signaturesOffset_; } else { return SignaturesOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        signaturesOffset_ = value;
      }
    }
    /// <summary>Gets whether the "signatures_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignaturesOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "signatures_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignaturesOffset() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "signatures_size" field.</summary>
    public const int SignaturesSizeFieldNumber = 5;
    private readonly static ulong SignaturesSizeDefaultValue = 0UL;

    private ulong signaturesSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SignaturesSize {
      get { if ((_hasBits0 & 4) != 0) { return signaturesSize_; } else { return SignaturesSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        signaturesSize_ = value;
      }
    }
    /// <summary>Gets whether the "signatures_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignaturesSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "signatures_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignaturesSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "minor_version" field.</summary>
    public const int MinorVersionFieldNumber = 12;
    private readonly static uint MinorVersionDefaultValue = 0;

    private uint minorVersion_;
    /// <summary>
    /// The minor version, also referred as "delta version", of the payload.
    /// Minor version 0 is full payload, everything else is delta payload.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MinorVersion {
      get { if ((_hasBits0 & 8) != 0) { return minorVersion_; } else { return MinorVersionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        minorVersion_ = value;
      }
    }
    /// <summary>Gets whether the "minor_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinorVersion {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "minor_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinorVersion() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "partitions" field.</summary>
    public const int PartitionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.PartitionUpdate> _repeated_partitions_codec
        = pb::FieldCodec.ForMessage(106, global::ChromeosUpdateEngine.PartitionUpdate.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate> partitions_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate>();
    /// <summary>
    /// Only present in major version >= 2. List of partitions that will be
    /// updated, in the order they will be updated. This field replaces the
    /// |install_operations|, |kernel_install_operations| and the
    /// |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
    /// array can have more than two partitions if needed, and they are identified
    /// by the partition name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate> Partitions {
      get { return partitions_; }
    }

    /// <summary>Field number for the "max_timestamp" field.</summary>
    public const int MaxTimestampFieldNumber = 14;
    private readonly static long MaxTimestampDefaultValue = 0L;

    private long maxTimestamp_;
    /// <summary>
    /// The maximum timestamp of the OS allowed to apply this payload.
    /// Can be used to prevent downgrading the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MaxTimestamp {
      get { if ((_hasBits0 & 16) != 0) { return maxTimestamp_; } else { return MaxTimestampDefaultValue; } }
      set {
        _hasBits0 |= 16;
        maxTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "max_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxTimestamp {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "max_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxTimestamp() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "dynamic_partition_metadata" field.</summary>
    public const int DynamicPartitionMetadataFieldNumber = 15;
    private global::ChromeosUpdateEngine.DynamicPartitionMetadata dynamicPartitionMetadata_;
    /// <summary>
    /// Metadata related to all dynamic partitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ChromeosUpdateEngine.DynamicPartitionMetadata DynamicPartitionMetadata {
      get { return dynamicPartitionMetadata_; }
      set {
        dynamicPartitionMetadata_ = value;
      }
    }

    /// <summary>Field number for the "partial_update" field.</summary>
    public const int PartialUpdateFieldNumber = 16;
    private readonly static bool PartialUpdateDefaultValue = false;

    private bool partialUpdate_;
    /// <summary>
    /// If the payload only updates a subset of partitions on the device.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PartialUpdate {
      get { if ((_hasBits0 & 32) != 0) { return partialUpdate_; } else { return PartialUpdateDefaultValue; } }
      set {
        _hasBits0 |= 32;
        partialUpdate_ = value;
      }
    }
    /// <summary>Gets whether the "partial_update" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPartialUpdate {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "partial_update" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPartialUpdate() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "apex_info" field.</summary>
    public const int ApexInfoFieldNumber = 17;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.ApexInfo> _repeated_apexInfo_codec
        = pb::FieldCodec.ForMessage(138, global::ChromeosUpdateEngine.ApexInfo.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo> apexInfo_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo>();
    /// <summary>
    /// Information on compressed APEX to figure out how much space is required for
    /// their decompression
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.ApexInfo> ApexInfo {
      get { return apexInfo_; }
    }

    /// <summary>Field number for the "security_patch_level" field.</summary>
    public const int SecurityPatchLevelFieldNumber = 18;
    private readonly static string SecurityPatchLevelDefaultValue = "";

    private string securityPatchLevel_;
    /// <summary>
    /// Security patch level of the device, usually in the format of
    /// yyyy-mm-dd
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecurityPatchLevel {
      get { return securityPatchLevel_ ?? SecurityPatchLevelDefaultValue; }
      set {
        securityPatchLevel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "security_patch_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecurityPatchLevel {
      get { return securityPatchLevel_ != null; }
    }
    /// <summary>Clears the value of the "security_patch_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecurityPatchLevel() {
      securityPatchLevel_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DeltaArchiveManifest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DeltaArchiveManifest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BlockSize != other.BlockSize) return false;
      if (SignaturesOffset != other.SignaturesOffset) return false;
      if (SignaturesSize != other.SignaturesSize) return false;
      if (MinorVersion != other.MinorVersion) return false;
      if(!partitions_.Equals(other.partitions_)) return false;
      if (MaxTimestamp != other.MaxTimestamp) return false;
      if (!object.Equals(DynamicPartitionMetadata, other.DynamicPartitionMetadata)) return false;
      if (PartialUpdate != other.PartialUpdate) return false;
      if(!apexInfo_.Equals(other.apexInfo_)) return false;
      if (SecurityPatchLevel != other.SecurityPatchLevel) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBlockSize) hash ^= BlockSize.GetHashCode();
      if (HasSignaturesOffset) hash ^= SignaturesOffset.GetHashCode();
      if (HasSignaturesSize) hash ^= SignaturesSize.GetHashCode();
      if (HasMinorVersion) hash ^= MinorVersion.GetHashCode();
      hash ^= partitions_.GetHashCode();
      if (HasMaxTimestamp) hash ^= MaxTimestamp.GetHashCode();
      if (dynamicPartitionMetadata_ != null) hash ^= DynamicPartitionMetadata.GetHashCode();
      if (HasPartialUpdate) hash ^= PartialUpdate.GetHashCode();
      hash ^= apexInfo_.GetHashCode();
      if (HasSecurityPatchLevel) hash ^= SecurityPatchLevel.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasBlockSize) {
        output.WriteRawTag(24);
        output.WriteUInt32(BlockSize);
      }
      if (HasSignaturesOffset) {
        output.WriteRawTag(32);
        output.WriteUInt64(SignaturesOffset);
      }
      if (HasSignaturesSize) {
        output.WriteRawTag(40);
        output.WriteUInt64(SignaturesSize);
      }
      if (HasMinorVersion) {
        output.WriteRawTag(96);
        output.WriteUInt32(MinorVersion);
      }
      partitions_.WriteTo(output, _repeated_partitions_codec);
      if (HasMaxTimestamp) {
        output.WriteRawTag(112);
        output.WriteInt64(MaxTimestamp);
      }
      if (dynamicPartitionMetadata_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DynamicPartitionMetadata);
      }
      if (HasPartialUpdate) {
        output.WriteRawTag(128, 1);
        output.WriteBool(PartialUpdate);
      }
      apexInfo_.WriteTo(output, _repeated_apexInfo_codec);
      if (HasSecurityPatchLevel) {
        output.WriteRawTag(146, 1);
        output.WriteString(SecurityPatchLevel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasBlockSize) {
        output.WriteRawTag(24);
        output.WriteUInt32(BlockSize);
      }
      if (HasSignaturesOffset) {
        output.WriteRawTag(32);
        output.WriteUInt64(SignaturesOffset);
      }
      if (HasSignaturesSize) {
        output.WriteRawTag(40);
        output.WriteUInt64(SignaturesSize);
      }
      if (HasMinorVersion) {
        output.WriteRawTag(96);
        output.WriteUInt32(MinorVersion);
      }
      partitions_.WriteTo(ref output, _repeated_partitions_codec);
      if (HasMaxTimestamp) {
        output.WriteRawTag(112);
        output.WriteInt64(MaxTimestamp);
      }
      if (dynamicPartitionMetadata_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DynamicPartitionMetadata);
      }
      if (HasPartialUpdate) {
        output.WriteRawTag(128, 1);
        output.WriteBool(PartialUpdate);
      }
      apexInfo_.WriteTo(ref output, _repeated_apexInfo_codec);
      if (HasSecurityPatchLevel) {
        output.WriteRawTag(146, 1);
        output.WriteString(SecurityPatchLevel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasBlockSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BlockSize);
      }
      if (HasSignaturesOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SignaturesOffset);
      }
      if (HasSignaturesSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SignaturesSize);
      }
      if (HasMinorVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinorVersion);
      }
      size += partitions_.CalculateSize(_repeated_partitions_codec);
      if (HasMaxTimestamp) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxTimestamp);
      }
      if (dynamicPartitionMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicPartitionMetadata);
      }
      if (HasPartialUpdate) {
        size += 2 + 1;
      }
      size += apexInfo_.CalculateSize(_repeated_apexInfo_codec);
      if (HasSecurityPatchLevel) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SecurityPatchLevel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DeltaArchiveManifest other) {
      if (other == null) {
        return;
      }
      if (other.HasBlockSize) {
        BlockSize = other.BlockSize;
      }
      if (other.HasSignaturesOffset) {
        SignaturesOffset = other.SignaturesOffset;
      }
      if (other.HasSignaturesSize) {
        SignaturesSize = other.SignaturesSize;
      }
      if (other.HasMinorVersion) {
        MinorVersion = other.MinorVersion;
      }
      partitions_.Add(other.partitions_);
      if (other.HasMaxTimestamp) {
        MaxTimestamp = other.MaxTimestamp;
      }
      if (other.dynamicPartitionMetadata_ != null) {
        if (dynamicPartitionMetadata_ == null) {
          DynamicPartitionMetadata = new global::ChromeosUpdateEngine.DynamicPartitionMetadata();
        }
        DynamicPartitionMetadata.MergeFrom(other.DynamicPartitionMetadata);
      }
      if (other.HasPartialUpdate) {
        PartialUpdate = other.PartialUpdate;
      }
      apexInfo_.Add(other.apexInfo_);
      if (other.HasSecurityPatchLevel) {
        SecurityPatchLevel = other.SecurityPatchLevel;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 24: {
            BlockSize = input.ReadUInt32();
            break;
          }
          case 32: {
            SignaturesOffset = input.ReadUInt64();
            break;
          }
          case 40: {
            SignaturesSize = input.ReadUInt64();
            break;
          }
          case 96: {
            MinorVersion = input.ReadUInt32();
            break;
          }
          case 106: {
            partitions_.AddEntriesFrom(input, _repeated_partitions_codec);
            break;
          }
          case 112: {
            MaxTimestamp = input.ReadInt64();
            break;
          }
          case 122: {
            if (dynamicPartitionMetadata_ == null) {
              DynamicPartitionMetadata = new global::ChromeosUpdateEngine.DynamicPartitionMetadata();
            }
            input.ReadMessage(DynamicPartitionMetadata);
            break;
          }
          case 128: {
            PartialUpdate = input.ReadBool();
            break;
          }
          case 138: {
            apexInfo_.AddEntriesFrom(input, _repeated_apexInfo_codec);
            break;
          }
          case 146: {
            SecurityPatchLevel = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 24: {
            BlockSize = input.ReadUInt32();
            break;
          }
          case 32: {
            SignaturesOffset = input.ReadUInt64();
            break;
          }
          case 40: {
            SignaturesSize = input.ReadUInt64();
            break;
          }
          case 96: {
            MinorVersion = input.ReadUInt32();
            break;
          }
          case 106: {
            partitions_.AddEntriesFrom(ref input, _repeated_partitions_codec);
            break;
          }
          case 112: {
            MaxTimestamp = input.ReadInt64();
            break;
          }
          case 122: {
            if (dynamicPartitionMetadata_ == null) {
              DynamicPartitionMetadata = new global::ChromeosUpdateEngine.DynamicPartitionMetadata();
            }
            input.ReadMessage(DynamicPartitionMetadata);
            break;
          }
          case 128: {
            PartialUpdate = input.ReadBool();
            break;
          }
          case 138: {
            apexInfo_.AddEntriesFrom(ref input, _repeated_apexInfo_codec);
            break;
          }
          case 146: {
            SecurityPatchLevel = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
